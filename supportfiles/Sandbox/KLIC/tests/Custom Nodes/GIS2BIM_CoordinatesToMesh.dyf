{
  "Uuid": "6f0383e4-88d4-4fda-be7c-cd9c8d507eb3",
  "IsCustomNode": true,
  "Category": "KC.GIS2BIM",
  "Description": "Creates a Mesh from a list of Coordinates.",
  "Name": "CoordinatesToMesh",
  "ElementResolver": {
    "ResolutionMap": {
      "List": {
        "Key": "List",
        "Value": "BuiltIn.ds"
      }
    }
  },
  "Inputs": [],
  "Outputs": [],
  "Nodes": [
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSFunction, DynamoCore",
      "NodeType": "FunctionNode",
      "FunctionSignature": "Revit.Elements.DirectShape.ByMesh@Autodesk.DesignScript.Geometry.Mesh,Revit.Elements.Category,Revit.Elements.Material,string",
      "Id": "84d9b7dc22fe49fda3da69b2d9e52651",
      "Inputs": [
        {
          "Id": "2765eafbe945415eb3168679c22d955c",
          "Name": "mesh",
          "Description": "A Mesh that will be tessellated and placed in the Revit model as a DirectShape\n\nMesh",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "43de8a2e25c945378a1ceb6eb1c281ef",
          "Name": "category",
          "Description": "Must be a top level Built-in Category\n\nCategory",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "5ebb31f30e7040b1a7529912dba6b1af",
          "Name": "material",
          "Description": "A Material to apply to the faces of the DirectShape\n\nMaterial\nDefault value : Revit.Elements.DirectShape.DynamoPreviewMaterial",
          "UsingDefaultValue": true,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "c0f6f0d646a94898b639760061632c65",
          "Name": "name",
          "Description": "A string name for the DirectShape\n\nstring\nDefault value : \"DirectShape\"",
          "UsingDefaultValue": true,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "0c98d42776fb49969551d4f22df77fa9",
          "Name": "DirectShape",
          "Description": "A DirectShape Element",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Auto",
      "Description": "Create a Revit DirectShape given some geometry, a name for the shape, a Category, and Material. The geometry will be tessellated before being placed in the Revit model The category of a DirectShape cannot be changed after creation, so a new DirectShape will be generated if the category input is changed.\n\nDirectShape.ByMesh (mesh: Mesh, category: Category, material: Material = Revit.Elements.DirectShape.DynamoPreviewMaterial, name: string = \"DirectShape\"): DirectShape"
    },
    {
      "ConcreteType": "DSRevitNodesUI.Categories, DSRevitNodesUI",
      "SelectedIndex": 264,
      "SelectedString": "OST_GenericModel",
      "NodeType": "ExtensionNode",
      "Id": "50055aa76da046bf8d5b20db8495b0fd",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "4f8ec07e2f5c4b92be17203beed5a511",
          "Name": "Category",
          "Description": "The selected Category.",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "All built-in categories."
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSFunction, DynamoCore",
      "NodeType": "FunctionNode",
      "FunctionSignature": "Revit.Elements.Material.ByName@string",
      "Id": "1ff61913bc794e58b9593bd2baa56dcb",
      "Inputs": [
        {
          "Id": "9172c60142f24d74bc335505da4ca3dd",
          "Name": "name",
          "Description": "The name of the material\n\nstring",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "53364c7873ee4e5fb6b3b94f82e934e7",
          "Name": "Material",
          "Description": "Material",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Auto",
      "Description": "Select a material from the current document by the name\n\nMaterial.ByName (name: string): Material"
    },
    {
      "ConcreteType": "DSRevitNodesUI.RevitPhases, DSRevitNodesUI",
      "SelectedIndex": 0,
      "SelectedString": "Existing",
      "NodeType": "ExtensionNode",
      "Id": "ec249a025cbd427dada27c7819866662",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "e77fcbe6436446d4b27e5f3885f5baac",
          "Name": "Phase",
          "Description": "The selected Phase",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Select an existing Revit Phase from the active document."
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CustomNodes.Function, DynamoCore",
      "FunctionSignature": "d5628e40-52de-47c9-b35b-c201d87344e0",
      "FunctionType": "Graph",
      "NodeType": "FunctionNode",
      "Id": "78513de64b9040d4b69d45a6cdabf953",
      "Inputs": [
        {
          "Id": "250e9619a45344df8caded49c40d4efc",
          "Name": "tkMesh",
          "Description": "var",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "20280da178fb4bb88e88fc2115185b26",
          "Name": "mesh",
          "Description": "return value",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Auto",
      "Description": "Attempts to convert a toolkit mesh to a Dynamo mesh. You obviously need to have the appropriate version of the mesh toolkit package downloaded first."
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSFunction, DynamoCore",
      "NodeType": "FunctionNode",
      "FunctionSignature": "Revit.Elements.Element.SetParameterByName@string,var",
      "Id": "b1bf77765c20477db79cc079fd8cffb4",
      "Inputs": [
        {
          "Id": "d4b4b0d27ab54aca838499b084f17fc4",
          "Name": "element",
          "Description": "Revit.Elements.Element",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "9c2c5ec9f8204054a1d92e8962659581",
          "Name": "parameterName",
          "Description": "The name of the parameter to set.\n\nstring",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "a4013a98dd144dfe936083d7a042c817",
          "Name": "value",
          "Description": "The value.\n\nvar",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "a0d99decad11416b82c4b85178b1cdd1",
          "Name": "Element",
          "Description": "Element",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Auto",
      "Description": "Set one of the element's parameters.\n\nElement.SetParameterByName (parameterName: string, value: var): Element"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.ZeroTouch.DSFunction, DynamoCore",
      "NodeType": "FunctionNode",
      "FunctionSignature": "Autodesk.Dynamo.MeshToolkit.Mesh.ByGeometry@Autodesk.DesignScript.Geometry.Geometry,double,int",
      "Id": "57c68139592d4ab1bb58f994aba16e98",
      "Inputs": [
        {
          "Id": "127aa31634594082a8874d4edc44bb31",
          "Name": "inputGeometry",
          "Description": "Geometry",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "3cd329dc0a2b4bf59928827378284646",
          "Name": "tolerance",
          "Description": "double\nDefault value : -1",
          "UsingDefaultValue": true,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "79d503aaf20d48079078a9cc5177897c",
          "Name": "maxGridLines",
          "Description": "int\nDefault value : 512",
          "UsingDefaultValue": true,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "3935c6fdb3104a25b31850386711a620",
          "Name": "Mesh",
          "Description": "Mesh",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Auto",
      "Description": "Convert a Geometry object such as a Solid or Surface into a Mesh. The resolution of the mesh is determined by the Dynamo render precision\n\nMesh.ByGeometry (inputGeometry: Geometry, tolerance: double = -1, maxGridLines: int = 512): Mesh"
    },
    {
      "ConcreteType": "CoreNodeModels.Input.StringInput, CoreNodeModels",
      "NodeType": "StringInputNode",
      "InputValue": "Phase Created",
      "Id": "95f782c6ae254c1090281d088cf4b8c0",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "0908ff7dde274eb9819286bd43819fd1",
          "Name": "",
          "Description": "String",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Creates a string."
    },
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "NodeType": "PythonScriptNode",
      "Code": "# Load the Python Standard and DesignScript Libraries\r\nimport sys\r\nimport clr\r\nclr.AddReference('ProtoGeometry')\r\nfrom Autodesk.DesignScript.Geometry import *\r\n\r\n# The inputs to this node will be stored as a list in the IN variables.\r\nvertices = IN[0]\r\nonlySolids = IN[1]\r\n\r\n# Place your code below this line\r\n\r\ngeometries = []\r\n\r\nbrokenSurfaceCounter = 0\r\nbrokenSolidCounter = 0\r\nbrokenPolyCounter = 0\r\n\r\nfor solidVertexLists in vertices:\r\n    surfaces = []\r\n    for surfaceVertexList in solidVertexLists:\r\n        points = []\r\n        for pointCoordinates in surfaceVertexList:\r\n            nextPoint = Point.ByCoordinates(pointCoordinates[0], pointCoordinates[1], pointCoordinates[2])\r\n            \r\n            # filter existing\r\n            duplicatePoint = False\r\n            for point in points:\r\n                if point.X == nextPoint.X and point.Y == nextPoint and point.Z == nextPoint.Z:\r\n                    duplicatePoint = True\r\n                    break\r\n                   \r\n            if not duplicatePoint:            \r\n                points.append(nextPoint)\r\n        \r\n        try:\r\n            surfaces.append(Surface.ByPerimeterPoints(points))\r\n        except Exception as error:\r\n            print('Error creating Surface:', error, points) \r\n            brokenSurfaceCounter += 1\r\n    try:\r\n        # buildingPolysurface = PolySurface.ByJoinedSurfaces(surfaces)\r\n        # buildingGeometry.append(PolySurface.ExtractSolids(buildingPolysurface)[0])\r\n        geometries.append(Solid.ByJoinedSurfaces(surfaces))\r\n    except Exception as error:\r\n        brokenSolidCounter += 1\r\n        try:\r\n            geometries.append(PolySurface.ByJoinedSurfaces(surfaces))\r\n        except:\r\n            if not onlySolids:\r\n                # Append List of Surfaces instead of solid :( \r\n                geometries.append(surfaces)\r\n                print('Error creating Solid or Polysurface - Outputting Surfaces:', error)\r\n            else:\r\n                 print('Error creating Solid or Polysurface - Deactivate \"OnlySolids\" to show single surfaces', error)\r\n            brokenPolyCounter += 1\r\n        \r\n\r\n# Assign your output to the OUT variable.\r\nOUT = geometries\r\n\r\n\r\nprint('Result:', brokenSurfaceCounter, ' failed surfaces,', brokenSolidCounter, 'failed Solids and ', brokenPolyCounter, 'failed fallback PolySurfaces.')\r\n",
      "Engine": "CPython3",
      "EngineName": "CPython3",
      "VariableInputPorts": true,
      "Id": "9ecfdf0e153f490aab1f9d5133d9c6c4",
      "Inputs": [
        {
          "Id": "513746fd16164c2eb82e96a2ee310591",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "ccf77e83bba5472eadffab26caf43400",
          "Name": "IN[1]",
          "Description": "Input #1",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "621510c435b74ad7b103a6ef0d0b408d",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded Python script."
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CustomNodes.Symbol, DynamoCore",
      "NodeType": "InputNode",
      "Parameter": {
        "Name": "coordinates",
        "TypeName": "var",
        "TypeRank": -1,
        "DefaultValue": null,
        "Description": ""
      },
      "Id": "f37e448600c14a3aa37a10fdc6148ce6",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "18e5d22dc94548b08b989204aa2e8017",
          "Name": "",
          "Description": "Symbol",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "A function parameter, use with custom nodes.\r\n\r\nYou can specify the type and default value for parameter. E.g.,\r\n\r\ninput : var[]..[]\r\nvalue : bool = false"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CustomNodes.Output, DynamoCore",
      "NodeType": "OutputNode",
      "ElementResolver": null,
      "Symbol": "Element;",
      "Id": "a2670fc79aef4da19eaf2d635ea96eeb",
      "Inputs": [
        {
          "Id": "3396c16d40f74d08b22a676dc9657740",
          "Name": "",
          "Description": "",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [],
      "Replication": "Disabled",
      "Description": "A function output, use with custom nodes"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CustomNodes.Symbol, DynamoCore",
      "NodeType": "InputNode",
      "Parameter": {
        "Name": "materialName",
        "TypeName": "string",
        "TypeRank": 0,
        "DefaultValue": "\"Default\"",
        "Description": ""
      },
      "Id": "646dc3783a5941f8a8f89897e5774300",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "4cf37c5186134ce89afbaca810c3bec0",
          "Name": "",
          "Description": "Symbol",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "A function parameter, use with custom nodes.\r\n\r\nYou can specify the type and default value for parameter. E.g.,\r\n\r\ninput : var[]..[]\r\nvalue : bool = false"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CustomNodes.Output, DynamoCore",
      "NodeType": "OutputNode",
      "ElementResolver": null,
      "Symbol": "Material;",
      "Id": "e850a8cb4aa643ee90c6e35a98863896",
      "Inputs": [
        {
          "Id": "f353d8678b9c487792c7e91ab92775a4",
          "Name": "",
          "Description": "",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [],
      "Replication": "Disabled",
      "Description": "A function output, use with custom nodes"
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CustomNodes.Symbol, DynamoCore",
      "NodeType": "InputNode",
      "Parameter": {
        "Name": "shapeName",
        "TypeName": "string",
        "TypeRank": 0,
        "DefaultValue": "\"NLRS_90_GM_3D_BAG1\"",
        "Description": ""
      },
      "Id": "f48bb5d33f4348b7abf387e475a9ad6c",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "8f35410c751a43299ef2cf66bc0eb6fc",
          "Name": "",
          "Description": "Symbol",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "A function parameter, use with custom nodes.\r\n\r\nYou can specify the type and default value for parameter. E.g.,\r\n\r\ninput : var[]..[]\r\nvalue : bool = false"
    },
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "NodeType": "PythonScriptNode",
      "Code": "# Load the Python Standard and DesignScript Libraries\r\nimport sys\r\nimport clr\r\nclr.AddReference('ProtoGeometry')\r\nfrom Autodesk.DesignScript.Geometry import *\r\n\r\nclr.AddReference('MeshToolkit')\r\nimport Autodesk.Dynamo.MeshToolkit as mtk\r\n\r\nimport System\r\nfrom System.Collections.Generic import List\r\n\r\nimport numpy as np\r\n\r\n##############\r\n# HELPERS\r\n#############\r\n\r\n# ==============================================================================\r\n#\r\n# Double linked list\r\n#\r\n# ==============================================================================\r\n\r\n__author__    = 'Nils Olofsson'\r\n__email__     = 'me@nilsolovsson.se'\r\n__copyright__ = 'Copyright 2021, AllSystemsPhenomenal'\r\n__license__   = 'MIT'\r\n\r\nclass Node:\r\n    \"\"\"\r\n        Node element in a DoubleLinkedList.\r\n        Each node in a valid list is associated with a value/data element and\r\n        with its left and right neighbor.\r\n        [Prev. node]<--[Node]-->[Next node]\r\n                         |\r\n                       [Data]\r\n    \"\"\"\r\n\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass DoubleLinkedList:\r\n    \"\"\"\r\n        A double linked list. Each element keeps a reference to both left and\r\n        right neighbor. This allows e.g. for easy removal of elements.\r\n        The list is circular and is usually considered traversed when the next element\r\n        is the same element as when when we started.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        self.first = None\r\n        self.size  = 0\r\n\r\n    def __str__(self):\r\n        if self.first==None:\r\n            return '[]'\r\n        msg = '['\r\n        msg += str(self.first.data)\r\n        node = self.first.next\r\n        while node != self.first:\r\n            msg += ', ' + str(node.data)\r\n            node = node.next\r\n        msg += ']'\r\n        return msg\r\n\r\n    def append(self, data):\r\n        self.size += 1\r\n        if self.first == None:\r\n            self.first = Node(data)\r\n            self.first.prev = self.first\r\n            self.first.next = self.first\r\n            return\r\n        node = Node(data)\r\n        last = self.first.prev\r\n        node.prev = last\r\n        node.next = self.first\r\n        last.next = node\r\n        self.first.prev = node\r\n\r\n    def remove(self, item):\r\n        if self.first==None:\r\n            return\r\n        rmv = None\r\n        node = self.first\r\n        if node.data == item:\r\n            rmv = node\r\n        node = node.next\r\n        while not rmv and node != self.first:\r\n            if node.data == item:\r\n                rmv = node\r\n            node = node.next\r\n        if rmv:\r\n            nxt = rmv.next\r\n            prv = rmv.prev\r\n            prv.next = nxt\r\n            nxt.prev = prv\r\n            self.size -= 1\r\n            if rmv == self.first:\r\n                self.first = nxt\r\n            if rmv == self.first:\r\n                self.first = None\r\n        return\r\n\r\n    def count(self):\r\n        if self.first==None:\r\n            return 0\r\n        i = 1\r\n        node = self.first.next\r\n        while node != self.first:\r\n            i+=1\r\n            node = node.next\r\n        return i\r\n\r\n    def flatten(self):\r\n        if self.first==None:\r\n            return []\r\n        l = []\r\n        node = self.first\r\n        l.append(node.data)\r\n        node = self.first.next\r\n        while node != self.first:\r\n            l.append(node.data)\r\n            node = node.next\r\n        return l\r\n\r\n\r\n# ==============================================================================\r\n#\r\n# Triangulation Code\r\n# based on Tutorial at https://all-systems-phenomenal.com/articles/ear_clipping_triangulation/index.php\r\n#\r\n# ==============================================================================\r\n\r\n\r\ndef angleCCW(a, b):\r\n    \"\"\"\r\n        Counter clock wise angle (radians) from normalized 2D vectors a to b\r\n    \"\"\"\r\n    dot = a[0]*b[0] + a[1]*b[1]\r\n    det = a[0]*b[1] - a[1]*b[0]\r\n    angle = np.arctan2(det, dot)\r\n    if angle<0.0 :\r\n        angle = 2.0*np.pi + angle\r\n    return angle\r\n\r\n\r\ndef isConvex(vertex_prev, vertex, vertex_next):\r\n    \"\"\"\r\n        Determine if vertex is locally convex.\r\n    \"\"\"\r\n    a = vertex_prev - vertex\r\n    b = vertex_next - vertex\r\n    internal_angle = angleCCW(b, a)\r\n    return internal_angle <= np.pi\r\n\r\n\r\ndef insideTriangle(a, b, c, p):\r\n    \"\"\"\r\n        Determine if a vertex p is inside (or \"on\") a triangle made of the\r\n        points a->b->c\r\n        http://blackpawn.com/texts/pointinpoly/\r\n    \"\"\"\r\n\r\n    #Compute vectors\r\n    v0 = c - a\r\n    v1 = b - a\r\n    v2 = p - a\r\n \r\n    # Compute dot products\r\n    dot00 = np.dot(v0, v0)\r\n    dot01 = np.dot(v0, v1)\r\n    dot02 = np.dot(v0, v2)\r\n    dot11 = np.dot(v1, v1)\r\n    dot12 = np.dot(v1, v2)\r\n    \r\n    # Compute barycentric coordinates\r\n    denom = dot00*dot11 - dot01*dot01\r\n    if abs(denom) < 1e-20:\r\n        return True\r\n    invDenom = 1.0 / denom\r\n    u = (dot11*dot02 - dot01*dot12) * invDenom\r\n    v = (dot00*dot12 - dot01*dot02) * invDenom\r\n    \r\n    # Check if point is in triangle\r\n    return (u >= 0) and (v >= 0) and (u + v < 1)\r\n\r\n\r\ndef triangulate(vertices_raw):\r\n    \"\"\"\r\n        Triangulation of a polygon in 2D.\r\n        Assumption that the polygon is simple, i.e has no holes, is closed and\r\n        has no crossings and also that its vertex order is counter clockwise.\r\n    \"\"\"\r\n\r\n    vertices = np.array(vertices_raw)\r\n\r\n    n, m = vertices.shape\r\n    indices = np.zeros([n-2, 3], dtype=int)\r\n\r\n    vertlist = DoubleLinkedList()\r\n    for i in range(0, n):\r\n        vertlist.append(i)\r\n    index_counter = 0\r\n\r\n    # Simplest possible algorithm. Create list of indexes.\r\n    # Find first ear vertex. Create triangle. Remove vertex from list\r\n    # Do this while number of vertices > 2.\r\n    node = vertlist.first\r\n    full_loop_counter = n\r\n    while vertlist.size > 2:\r\n        i = node.prev.data\r\n        j = node.data\r\n        k = node.next.data\r\n\r\n        vert_prev = vertices[i, :]\r\n        vert_current = vertices[j, :]\r\n        vert_next = vertices[k, :]\r\n\r\n        is_convex = isConvex(vert_prev, vert_current, vert_next)\r\n        is_ear = True\r\n        if is_convex:\r\n            test_node = node.next.next\r\n            while test_node!=node.prev and is_ear:\r\n                vert_test = vertices[test_node.data, :]\r\n                is_ear = not insideTriangle(vert_prev,\r\n                                            vert_current,\r\n                                            vert_next,\r\n                                            vert_test)\r\n                test_node = test_node.next\r\n        else:\r\n            is_ear = False\r\n\r\n        if is_ear:\r\n            indices[index_counter, :] = np.array([i, j, k], dtype=int)\r\n            index_counter += 1\r\n            vertlist.remove(node.data)\r\n            full_loop_counter = n\r\n        node = node.next\r\n        full_loop_counter -= 1\r\n\r\n        if full_loop_counter < 0:\r\n            print('CANT FIND MORE EARS - ERROR - CANCELLING TRIANGULATION')\r\n            break\r\n\r\n    return indices\r\n\r\n\r\n\r\n################\r\n# ACTUAL SCRIPT\r\n################\r\n\r\n\r\n# The inputs to this node will be stored as a list in the IN variables.\r\ngeometries = IN[0]\r\n\r\n# Place your code below this line\r\n\r\ndef pointInList(point, vertexList):\r\n    for index, vertex in enumerate(vertexList):\r\n        if point.X == vertex.X and point.Y == vertex.Y and point.Z == vertex.Z:\r\n            return index\r\n    return -1\r\n\r\ndef equalPoints2D(A, B):\r\n    return A[0] == B[0] and A[1] == B[1]\r\n    \r\ndef squareDistancePoints2D(A, B):\r\n    return (B[0] - A[0])**2 + (B[1] - A[1])**2\r\n \r\ndef isCounterClockwise(vertices):\r\n    edgeSum = 0\r\n    lastVertex = vertices[-1]\r\n    for vertex in vertices:\r\n        edgeSum += (vertex[0] - lastVertex[0])*(vertex[1] + lastVertex[1])\r\n        lastVertex = vertex\r\n\r\n    return edgeSum < 0\r\n    \r\ndef getLargestCoordinate(vertexList, index):\r\n    largest = float('-inf')\r\n    for vertex in vertexList:\r\n        if vertex[index] > largest:\r\n            largest = vertex[index]\r\n    return largest\r\n\r\ndef getLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4):\r\n    denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\r\n    if denom == 0:\r\n        return None  # Parallel.\r\n    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom\r\n    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom\r\n    if 0.0 <= ua <= 1.0 and 0.0 <= ub <= 1.0:\r\n        return (x1 + ua * (x2 - x1)), (y1 + ua * (y2 - y1))\r\n    return None\r\n\r\ndef getIntersectionEdge(outerPolygon, innerVertex):\r\n    lastVertex = outerPolygon[-1]\r\n    infiniteLineEnd = getLargestCoordinate(outerPolygon, 0) + 100\r\n    for index, vertex in enumerate(outerPolygon):\r\n        if lastVertex[0] >= innerVertex[0] or vertex[0] >= innerVertex[0]:\r\n            vertexInt = getLineIntersection(innerVertex[0], innerVertex[1], infiniteLineEnd, innerVertex[1], lastVertex[0], lastVertex[1], vertex[0], vertex[1]) \r\n            if vertexInt is not None:\r\n                return lastVertex, vertex, vertexInt, index\r\n        lastVertex = vertex\r\n    raise Exception('No intersection found... This should not happen - check the code') \r\n\r\n\r\nmeshGeometries = []\r\nfor geometry in geometries:\r\n    vertexList = []\r\n    indexList = []\r\n    \r\n    holesArePossible = type(geometry[0][0]) == list\r\n    \r\n    for surface in geometry:\r\n    \r\n        withHoles = False\r\n        \r\n        if holesArePossible and len(surface) > 1:\r\n            srfOuterBoundVertices = surface[0]\r\n            holes = surface[1:]\r\n            withHoles = True\r\n        elif holesArePossible and len(surface) == 1:\r\n            srfOuterBoundVertices = surface[0]\r\n        else:\r\n            srfOuterBoundVertices = surface\r\n    \r\n        if not withHoles and len(srfOuterBoundVertices) < 3:\r\n            print('Invadlid Surface - only', len(srfOuterBoundVertices), 'Vertexes')\r\n            continue\r\n        elif not withHoles and len(srfOuterBoundVertices) == 3:\r\n            for point in srfOuterBoundVertices:\r\n                geoPoint = Point.ByCoordinates(point[0], point[1], point[2])\r\n                pointIndex = pointInList(geoPoint, vertexList)\r\n                if pointIndex > -1:\r\n                    indexList.append(pointIndex)\r\n                else:\r\n                    vertexList.append(geoPoint)\r\n                    indexList.append(len(vertexList) - 1)\r\n        else:\r\n            # Create Geometry Points\r\n            points = []\r\n            for point in srfOuterBoundVertices:\r\n                points.append(Point.ByCoordinates(point[0], point[1], point[2]))\r\n            \r\n            if withHoles:            \r\n                holesPoints = []\r\n                for hole in holes:\r\n                    holePoints = []\r\n                    for point in hole:\r\n                        holePoints.append(Point.ByCoordinates(point[0], point[1], point[2]))\r\n                    holesPoints.append(holePoints)\r\n            \r\n            # Get plane/coord system of surface\r\n            surfacePlane = Plane.ByBestFitThroughPoints(points)\r\n            \r\n            # Transform points into it\r\n            fromCS = CoordinateSystem.ByOrigin(0,0,0)\r\n            toCS = CoordinateSystem.ByPlane(surfacePlane)\r\n            transformedPoints = []\r\n            for point in points:\r\n                transformedPoint = point.Transform(toCS, fromCS)\r\n                transformedPoints.append([transformedPoint.X, transformedPoint.Y])\r\n                \r\n            if isCounterClockwise(transformedPoints):\r\n                polyPoints = transformedPoints\r\n            else:\r\n                polyPoints = np.flip(transformedPoints, 0)\r\n                points = np.flip(points, 0)\r\n                \r\n            if withHoles:\r\n                transformedHolesPoints = []\r\n                for index, hole in enumerate(holesPoints):\r\n                    transformedHolePoints = []\r\n                    for point in hole:\r\n                        transformedPoint = point.Transform(toCS, fromCS)\r\n                        transformedHolePoints.append([transformedPoint.X, transformedPoint.Y])\r\n                    \r\n                    # Make sure the transforme hole vertices are clockwise and the original points are ordered the same\r\n                    if not isCounterClockwise(transformedHolePoints):\r\n                        transformedHolesPoints.append(transformedHolePoints)\r\n                    else:\r\n                        transformedHolesPoints.append(np.flip(transformedHolePoints, 0))                      \r\n                        holesPoints[index] = np.flip(holesPoints[index], 0)\r\n                    \r\n                # Combine outer (polyPoints) and inner (transformedHolesPoints) boundaries\r\n                largestXs = []\r\n                largestXIndices = []\r\n                for hole in transformedHolesPoints:\r\n                    largestX = float('-inf')\r\n                    largestXIndex = 0\r\n                    for index, point in enumerate(hole):\r\n                        if point[0] > largestX:\r\n                            largestX = point[0]\r\n                            largestXIndex = index\r\n                    largestXs.append(largestX)\r\n                    largestXIndices.append(largestXIndex)\r\n                 \r\n                holeOrder = np.flip(np.argsort(largestXs))\r\n              \r\n                for holeIndex in holeOrder:\r\n                    nextHole = transformedHolesPoints[holeIndex]\r\n                    \r\n                    startVertex = nextHole[largestXIndices[holeIndex]]\r\n                    shiftedHole = np.roll(nextHole, -1 * largestXIndices[holeIndex], 0)\r\n                    shiftedHolePoints = np.roll(holesPoints[holeIndex], -largestXIndices[holeIndex])\r\n                    \r\n                    try:\r\n                        edgeA, edgeB, edgeInt, edgeBIndex = getIntersectionEdge(polyPoints, startVertex)\r\n                    except:\r\n                        print('ERROR connecting hole', polyPoints, startVertex, nextHole)\r\n                        continue\r\n                        \r\n                    if equalPoints2D(edgeInt, edgeA):\r\n                        # Point A is already mutually visible\r\n                        edgeAIndex = edgeBIndex - 1\r\n                        if edgeAIndex < 0:\r\n                            edgeAIndex = len(transformedPoints) - 1\r\n                      \r\n                        polyPoints = np.concatenate((polyPoints[:edgeAIndex + 1], shiftedHole, [shiftedHole[0]], polyPoints[edgeAIndex:]))\r\n                        points = np.concatenate((points[:edgeAIndex + 1], shiftedHolePoints, [shiftedHolePoints[0]], points[edgeAIndex:]))                        \r\n                        continue\r\n                    elif equalPoints2D(edgeInt, edgeB):\r\n                        polyPoints = np.concatenate((polyPoints[:edgeBIndex + 1], shiftedHole, [shiftedHole[0]], polyPoints[edgeBIndex:]))\r\n                        points = np.concatenate((points[:edgeBIndex + 1], shiftedHolePoints, [shiftedHolePoints[0]], points[edgeBIndex:]))\r\n                        continue\r\n                    else:\r\n                        candidatePoint = edgeA if edgeA[0] >= edgeB[0] else edgeB\r\n                        candidateIndex = edgeBIndex - 1 if edgeA[0] >= edgeB[0] else edgeBIndex\r\n                        otherCandidateIndices = []\r\n                        for index, point in enumerate(polyPoints):\r\n                            prevIndex = index - 1\r\n                            nextIndex = index + 1 if index + 1 < len(polyPoints) else 0\r\n                            if not isConvex(polyPoints[prevIndex], point, polyPoints[nextIndex]) and insideTriangle(startVertex, edgeInt, candidatePoint, point):\r\n                                otherCandidateIndices.append(index)\r\n                        \r\n                        distance = 0\r\n                        for index in otherCandidateIndices:\r\n                            point = transformedPoints[index]\r\n                            nextDistance = squareDistancePoints2D(startVertex, point)\r\n                            if nextDistance > distance:\r\n                                distance = nextDistance\r\n                                candidateIndex = index\r\n                        \r\n                        polyPoints = np.concatenate((polyPoints[:candidateIndex + 1], shiftedHole, [shiftedHole[0]], polyPoints[candidateIndex:]))\r\n                        points = np.concatenate((points[:candidateIndex + 1], shiftedHolePoints, [shiftedHolePoints[0]], points[candidateIndex:]))\r\n                        \r\n                        \r\n            # print('TRANSFORM', polyPoints)\r\n            \r\n            # Triangulate\r\n            triangulation = triangulate(polyPoints)\r\n            \r\n            # print('TRIANGULATE', triangulation)\r\n            \r\n            # Piece the mesh together\r\n            for triangle in triangulation:\r\n                for vertex in triangle:\r\n                    threeDPoint = points[vertex]\r\n                    pointIndex = pointInList(threeDPoint, vertexList)\r\n                    if pointIndex > -1:\r\n                        indexList.append(pointIndex)\r\n                    else:\r\n                        vertexList.append(threeDPoint)\r\n                        indexList.append(len(vertexList) - 1)\r\n\r\n          \r\n    meshIndices = List[int](indexList) # would fail when using 'indices' directly\r\n    simpleMesh = mtk.Mesh.ByVerticesAndIndices(vertexList, meshIndices)\r\n    improvedMesh = mtk.Mesh.Repair(simpleMesh)    \r\n    meshGeometries.append(improvedMesh)\r\n\r\n# Assign your output to the OUT variable.\r\nOUT = meshGeometries\r\n",
      "Engine": "CPython3",
      "EngineName": "CPython3",
      "VariableInputPorts": true,
      "Id": "91ab70cd72a640dfa9dcc726a91cff39",
      "Inputs": [
        {
          "Id": "31ac396e64f14f5c8ae220e310bd0c47",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "7ea34a509a2744538b20d935678ec1c4",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded Python script."
    },
    {
      "ConcreteType": "CoreNodeModels.Watch, CoreNodeModels",
      "NodeType": "ExtensionNode",
      "Id": "10f1b88a64a4480b9427716299d30e2b",
      "Inputs": [
        {
          "Id": "d05803ef2fac4141801120c992a1134d",
          "Name": "",
          "Description": "Node to show output from",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "94380801d3cd4c90a592f9dddfa3639a",
          "Name": "",
          "Description": "Node output",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Visualize the node's output"
    }
  ],
  "Connectors": [
    {
      "Start": "0c98d42776fb49969551d4f22df77fa9",
      "End": "d4b4b0d27ab54aca838499b084f17fc4",
      "Id": "1d48798178b74c07a71d8e870f9a9d9c",
      "IsHidden": "False"
    },
    {
      "Start": "4f8ec07e2f5c4b92be17203beed5a511",
      "End": "43de8a2e25c945378a1ceb6eb1c281ef",
      "Id": "81677fca794c4c8b8ff70e91217229b6",
      "IsHidden": "False"
    },
    {
      "Start": "53364c7873ee4e5fb6b3b94f82e934e7",
      "End": "5ebb31f30e7040b1a7529912dba6b1af",
      "Id": "9bc616c5a6dc4f52afeeecbf1ba27fa4",
      "IsHidden": "False"
    },
    {
      "Start": "53364c7873ee4e5fb6b3b94f82e934e7",
      "End": "f353d8678b9c487792c7e91ab92775a4",
      "Id": "9e24837b2aa1481384c8df47e6b86b4d",
      "IsHidden": "False"
    },
    {
      "Start": "e77fcbe6436446d4b27e5f3885f5baac",
      "End": "a4013a98dd144dfe936083d7a042c817",
      "Id": "fc4f2feb67da4f70a8c91855259d46d5",
      "IsHidden": "False"
    },
    {
      "Start": "20280da178fb4bb88e88fc2115185b26",
      "End": "2765eafbe945415eb3168679c22d955c",
      "Id": "36d1b622eada4426b27db2866a6c9dbe",
      "IsHidden": "False"
    },
    {
      "Start": "a0d99decad11416b82c4b85178b1cdd1",
      "End": "3396c16d40f74d08b22a676dc9657740",
      "Id": "c263718916c2455f9d51e76e8537b9f9",
      "IsHidden": "False"
    },
    {
      "Start": "0908ff7dde274eb9819286bd43819fd1",
      "End": "9c2c5ec9f8204054a1d92e8962659581",
      "Id": "14793d0399a149e38864ac893c46a5d7",
      "IsHidden": "False"
    },
    {
      "Start": "621510c435b74ad7b103a6ef0d0b408d",
      "End": "127aa31634594082a8874d4edc44bb31",
      "Id": "35eaeda72d294da48907a3d4a35216c1",
      "IsHidden": "False"
    },
    {
      "Start": "18e5d22dc94548b08b989204aa2e8017",
      "End": "31ac396e64f14f5c8ae220e310bd0c47",
      "Id": "4fe23e829de643b79eff54abb27bf882",
      "IsHidden": "False"
    },
    {
      "Start": "4cf37c5186134ce89afbaca810c3bec0",
      "End": "9172c60142f24d74bc335505da4ca3dd",
      "Id": "9d76935200254ce6a1736784b2edf20f",
      "IsHidden": "False"
    },
    {
      "Start": "8f35410c751a43299ef2cf66bc0eb6fc",
      "End": "c0f6f0d646a94898b639760061632c65",
      "Id": "24077679ff064b3d99cfd19b14075902",
      "IsHidden": "False"
    },
    {
      "Start": "7ea34a509a2744538b20d935678ec1c4",
      "End": "250e9619a45344df8caded49c40d4efc",
      "Id": "500fe03bf95d47bf8e7d32c3a4654279",
      "IsHidden": "False"
    },
    {
      "Start": "7ea34a509a2744538b20d935678ec1c4",
      "End": "d05803ef2fac4141801120c992a1134d",
      "Id": "40687819a6dc41ad97a7cc451f82e851",
      "IsHidden": "False"
    }
  ],
  "Dependencies": [
    "d5628e40-52de-47c9-b35b-c201d87344e0"
  ],
  "NodeLibraryDependencies": [
    {
      "Name": "spring nodes",
      "Version": "210.1.1",
      "ReferenceType": "Package",
      "Nodes": [
        "78513de64b9040d4b69d45a6cdabf953"
      ]
    },
    {
      "Name": "MeshToolkit",
      "Version": "3.0.0",
      "ReferenceType": "Package",
      "Nodes": [
        "57c68139592d4ab1bb58f994aba16e98"
      ]
    }
  ],
  "Author": "None provided",
  "Bindings": [],
  "View": {
    "Dynamo": {
      "ScaleFactor": 1.0,
      "HasRunWithoutCrash": false,
      "IsVisibleInDynamoLibrary": true,
      "Version": "2.16.2.5624",
      "RunType": "Manual",
      "RunPeriod": "1000"
    },
    "Camera": {
      "Name": "Background Preview",
      "EyeX": -983462.5,
      "EyeY": 776540.6875,
      "EyeZ": 764853.5625,
      "LookX": 797080.25,
      "LookY": -877353.6875,
      "LookZ": -558277.4375,
      "UpX": 0.42185685038566589,
      "UpY": 0.85716593265533447,
      "UpZ": -0.29547160863876343
    },
    "ConnectorPins": [],
    "NodeViews": [
      {
        "Name": "DirectShape.ByMesh",
        "ShowGeometry": true,
        "Id": "84d9b7dc22fe49fda3da69b2d9e52651",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 814.35519541010945,
        "Y": -348.8816213715769
      },
      {
        "Name": "Categories",
        "ShowGeometry": true,
        "Id": "50055aa76da046bf8d5b20db8495b0fd",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 406.7144141910569,
        "Y": -325.76202587570089
      },
      {
        "Name": "Material.ByName",
        "ShowGeometry": true,
        "Id": "1ff61913bc794e58b9593bd2baa56dcb",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 404.36325722225638,
        "Y": -184.63107434854953
      },
      {
        "Name": "Select Phase",
        "ShowGeometry": true,
        "Id": "ec249a025cbd427dada27c7819866662",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 1482.0608340744575,
        "Y": -552.4272125272239
      },
      {
        "Name": "ꟿ TkMesh.ToMesh",
        "ShowGeometry": true,
        "Id": "78513de64b9040d4b69d45a6cdabf953",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 409.72749581848211,
        "Y": -460.32287059012566
      },
      {
        "Name": "Element.SetParameterByName",
        "ShowGeometry": true,
        "Id": "b1bf77765c20477db79cc079fd8cffb4",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 1719.5317989198063,
        "Y": -672.45775273301888
      },
      {
        "Name": "Mesh.ByGeometry",
        "ShowGeometry": true,
        "Id": "57c68139592d4ab1bb58f994aba16e98",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 79.564365151889888,
        "Y": 214.70127821902031
      },
      {
        "Name": "String",
        "ShowGeometry": true,
        "Id": "95f782c6ae254c1090281d088cf4b8c0",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 1484.6571349941223,
        "Y": -759.40760778230015
      },
      {
        "Name": "GeometryFromPoints.py",
        "ShowGeometry": true,
        "Id": "9ecfdf0e153f490aab1f9d5133d9c6c4",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": true,
        "X": -403.57478681035059,
        "Y": 211.05968579562796
      },
      {
        "Name": "Input",
        "ShowGeometry": true,
        "Id": "f37e448600c14a3aa37a10fdc6148ce6",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": -532.101875819143,
        "Y": -533.72286696005028
      },
      {
        "Name": "Output",
        "ShowGeometry": true,
        "Id": "a2670fc79aef4da19eaf2d635ea96eeb",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 2254.0531623299767,
        "Y": -873.07287269971266
      },
      {
        "Name": "Input",
        "ShowGeometry": true,
        "Id": "646dc3783a5941f8a8f89897e5774300",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": -89.355393242021023,
        "Y": -137.10629438294842
      },
      {
        "Name": "Output",
        "ShowGeometry": true,
        "Id": "e850a8cb4aa643ee90c6e35a98863896",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 1789.5326640825663,
        "Y": -156.59832120800974
      },
      {
        "Name": "Input",
        "ShowGeometry": true,
        "Id": "f48bb5d33f4348b7abf387e475a9ad6c",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": -303.06742034788169,
        "Y": -293.50207258834206
      },
      {
        "Name": "MeshGeometryFromPoints.py",
        "ShowGeometry": true,
        "Id": "91ab70cd72a640dfa9dcc726a91cff39",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": -177.92284897058505,
        "Y": -529.35203241850672
      },
      {
        "Name": "Watch",
        "ShowGeometry": true,
        "Id": "10f1b88a64a4480b9427716299d30e2b",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 502.26439372774234,
        "Y": -849.53775140543576
      }
    ],
    "Annotations": [
      {
        "Id": "a1e1ec0cb05845dcaccb69c625ab9e14",
        "Title": "Place Mesh as DirectShape",
        "DescriptionText": null,
        "IsExpanded": true,
        "WidthAdjustment": 0.0,
        "HeightAdjustment": 0.0,
        "Nodes": [
          "84d9b7dc22fe49fda3da69b2d9e52651",
          "50055aa76da046bf8d5b20db8495b0fd",
          "78513de64b9040d4b69d45a6cdabf953",
          "1ff61913bc794e58b9593bd2baa56dcb"
        ],
        "HasNestedGroups": false,
        "Left": 394.36325722225638,
        "Top": -533.656203923459,
        "Width": 681.32527152118632,
        "Height": 480.69179624157613,
        "FontSize": 36.0,
        "InitialTop": -460.32287059012566,
        "InitialHeight": 324.3178542369717,
        "TextblockHeight": 63.333333333333336,
        "Background": "#FFC1D676"
      },
      {
        "Id": "7bca647520fb498fa4826ba846435657",
        "Title": "Set Phase and Parameters (might override color)",
        "DescriptionText": null,
        "IsExpanded": true,
        "WidthAdjustment": 0.0,
        "HeightAdjustment": 0.0,
        "Nodes": [
          "b1bf77765c20477db79cc079fd8cffb4",
          "95f782c6ae254c1090281d088cf4b8c0",
          "ec249a025cbd427dada27c7819866662"
        ],
        "HasNestedGroups": false,
        "Left": 1472.0608340744575,
        "Top": -876.07427444896678,
        "Width": 560.80429817868207,
        "Height": 455.31372858840956,
        "FontSize": 36.0,
        "InitialTop": -759.40760778230015,
        "InitialHeight": 265.03054020579503,
        "TextblockHeight": 106.66666666666667,
        "Background": "#FFC1D676"
      }
    ],
    "X": 548.47769926514457,
    "Y": 660.865699658351,
    "Zoom": 0.8401545874222891
  }
}